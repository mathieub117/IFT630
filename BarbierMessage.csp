_program()
    
_program_end

_program(dp)
    const baguettes := 5, round := 10
    _specs
        _process_spec1(baguetteQueryer,1,baguettes)
            _port(baguetteQueryer,pick, ())
            _port(baguetteQueryer,drop, ())
            _port(baguetteQueryer,test, ())

        _process_spec1(philosphe,1,baguettes)
            _port(philosophe,Think, ())
            _port(philosophe,Eat, ())
    _specs_end

    _process_body1(baguetteQueryer,i)
        var rightBaguetteDispo := true, leftBaguetteDispo := true
        var philEat := false, philThink := false
        _do
            _guard_i(true, philosophe[i],Think, ()) ->
                philThink := true
            _guard(philThink & rightBaguetteDispo & leftBaguetteDispo) ->
                phungry := false
                philThink := rightBaguetteDispo := rightBaguetteDispo := true
                _stmt_o(phil[i],eat, ())
            _guard_o(phungry & not haveL, waiter[L],need, ()) ->
                haveL := true
            _guard_o(phungry & not haveR, waiter[R],need, ()) ->
                haveR := true
            _guard_i(haveL & not peating & dirtyL, waiter[L],need, ()) ->
                haveL := dirtyL := false
            _guard_i(haveR & not peating & dirtyR, waiter[R],need, ()) ->
                haveR := dirtyR := false
            _guard_i(true, phil[i],full, ()) ->
                peating := false
        _od
    _process_end

    _process_body1(philosophe,i)
        fa k := 1 to baguettes ->
            _stmt_o(baguetteQueryer[i],pick, ())
            _stmt_i(baguetteQueryer[i],drop, ())
        af
    _process_end

_program_end